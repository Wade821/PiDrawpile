#!/bin/bash
drawpilescriptversion=0.1415
drawpile_script_version=$drawpilescriptversion
if echo $SSH_TTY | grep -q "/dev/pts/" ; then
	local_or_remote="Remote"
	# https://askubuntu.com/questions/538453/how-do-i-detect-if-the-current-session-is-an-ssh-session-via-bash
	# https://unix.stackexchange.com/questions/9605/how-can-i-detect-if-the-shell-is-controlled-from-ssh
else
    local_or_remote="Local"
fi
if [ x$DISPLAY != x ] ; then
	gui_status="GUI Enabled"
else
	gui_status="GUI Disabled"
fi
if lxterminal -v > /dev/null 2>&1; then
	terminal_in_use=lxterminal
	# Can run scripts in the background which doesn't make sense/work, so this should exit and reload into an interactive shell. 
	# echo "Using: lxterminal"
	tty -s; if [ $? -ne 0 ]; then lxterminal -e "$0"; exit; fi
elif gnome-terminal -h > /dev/null 2>&1; then
	terminal_in_use=gnome-terminal
	# Runs terminal in the forefront, so not necessary to run.
	# echo "Using: gnome-terminal"
	# tty -s; if [ $? -ne 0 ]; then gnome-terminal -e "$0"; exit; fi
else
	terminal_in_use=unknown-terminal
	# echo "Using: Unknown terminal"
fi
script_name=drawpile-file-backed-sessions-management
script_main_url=https://raw.githubusercontent.com/Bluestrings-Drawpile/PiDrawpile/master
script_directory="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
#In case I decide to change the name
github_account_name=Bluestrings-Drawpile
github_project_name=PiDrawpile
# When no path being used, should look like github_sub_folder_path=""
github_main_script_only_sub_folder_path=testing/

# Normal line
# sudo wget -q --show-progress "https://raw.githubusercontent.com/Bluestrings-Drawpile/PiDrawpile/master/testing/drawpile-installer-official-build-from-sources-with-listserver-and-webadmin2"
# sudo wget -q --force-progress "https://raw.githubusercontent.com/Bluestrings-Drawpile/PiDrawpile/master/testing/drawpile-installer-official-build-from-sources-with-listserver-and-webadmin2"
# Example line
# sudo wget -q --show-progress "https://raw.githubusercontent.com/$github_account_name/$github_project_name/master/$github_main_script_only_sub_folder_path$script_name"
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
# script_name=drawpile-file-backed-sessions-management
# drawpile_script_overall_master_version_URL=https://raw.githubusercontent.com/$github_account_name/$github_project_name/master/scripts-for-other-scripts-only/version.txt
# Do not alter script_main_url... instead, include subfolder in script_name variable. 
# See example included below for reference code.
#		sudo wget -q "$script_main_url/$script_name" --show-progress
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
# Text Formatting
# https://stackoverflow.com/questions/2924697/how-does-one-output-bold-text-in-bash
# Refer to this link for lots of details and samples of colors (text + backgrounds)
# http://linuxcommand.org/lc3_adv_tput.php
#
bold=$(tput bold)
underline=$(tput smul)
blink=$(tput blink)
# black text on white background
standout=$(tput smso)
# Useful for hiding output I guess???
invis=$(tput invis)

# Text Colors
red=$(tput setaf 1)
green=$(tput setaf 2)
# Text Formatting - Yellow looks orange unless used in bold mode. Also looks brown in Fedora.
# yellow=$(tput setaf 3)
yellow=$(tput setaf 11)
blue=$(tput setaf 4)
magenta=$(tput setaf 5)
cyan=$(tput setaf 6)

#Background Colors
red_b=$(tput setab 1)
green_b=$(tput setab 2)
# Text Formatting - Yellow looks orange unless used in bold mode. Also looks brown in Fedora.
# yellow_b=$(tput setab 3)
yellow_b=$(tput setab 11)
blue_b=$(tput setab 4)
magenta_b=$(tput setab 5)
cyan_b=$(tput setab 6)

normal=$(tput sgr0)

TICK=$( printf '\u2714\n' )
CROSS=$( printf '\u274c\n' )
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
app_installation_status_file=/home/drawpileuser/App-Installation-Status.txt
app_installation_status_file_bak=/home/drawpileuser/App-Installation-Status_bak.txt
# See the section below for the creation of the file in script.
# Cannot use sed on an empty file containing no characters or new lines. 
drawpile_configuration_values_file=/home/drawpileuser/Drawpile_Configuration_Values.txt
drawpile_configuration_values_file_bak=/home/drawpileuser/Drawpile_Configuration_Values_bak.txt

drawpile_completed_successfully_values_file=/home/drawpileuser/Drawpile_Completed_Values.txt
drawpile_completed_successfully_values_file_bak=/home/drawpileuser/Drawpile_Completed_Values_bak.txt
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
<<comment_VNC_EOF
sudo apt-get -q -y install realvnc-vnc-server
apt-cache policy realvnc-vnc-server
comment_VNC_EOF
# ----------------------------------------------------------------------------------
<<comment_VMware_EOF
If running a VM with VMWare ... 
     https://docs.vmware.com/en/VMware-Tools/12.2.0/com.vmware.vsphere.vmwaretools.doc/GUID-C48E1F14-240D-4DD1-8D4C-25B6EBE4BB0F.html
sudo apt-get update
sudo apt-get -q -y install open-vm-tools-desktop
sudo apt-get -q -y install open-vm-tools
comment_VMware_EOF
# ----------------------------------------------------------------------------------
<<comment_DarkMode_EOF
If Dark mode preferred:
Start, Preferences, Main Menu Editor. Go to Preferences, turn on Theme and Appearance Settings. Click Ok.
Go back to Start, Preferences, Theme and Appearance Settings. Turn on "Adwaita-Dark". 
 
For the title bars, go to "Window Boarder" and select one of the following:
Dark Options:			Artwiz-boxed, Nightmware, Nightmware-01, Nightmware-02, Nightmware-03, Onyx, Onyx-Citrus
Preferred Options: 	Artwiz-boxed, Nightmware, Nightmware-02, Onyx
comment_DarkMode_EOF
# ----------------------------------------------------------------------------------
<<comment_geany_EOF
Enable Dark Themes for Geany Text: View, Change Color Scheme...

mkdir -p -v /home/$USER/Public/Programs && cd "/home/$USER/Public/Programs"
git clone https://github.com/codebrainz/geany-themes.git
cd geany-themes
./install.sh
cp -r /home/$USER/Public/Programs/geany-themes/colorschemes ~/.config/geany/colorschemes/


Enable Dark Themes One-liner Command for Geany Text: View, Change Color Scheme...

mkdir -p -v /home/$USER/Public/Programs && cd "/home/$USER/Public/Programs" && git clone https://github.com/codebrainz/geany-themes.git && cd geany-themes && ./install.sh && cp -r /home/$USER/Public/Programs/geany-themes/colorschemes ~/.config/geany/colorschemes/
comment_geany_EOF
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
function pause () {
	read -s -n 1 -p "Press any key to continue . . ."
	echo ""
}

function command_die () {
    echo "$@" 1>&2
    exit 1
}

function drawpile_credits_function () {
	echo 'Made with the assistance of the original creator of Drawpile (Calle Laakkonen)'
	echo 'and the new developer askmeaboutloom! Donation links provided below.'
	echo
	echo 'Original Dev - Calle Laakkonen (PayPal):'
	echo "     ${underline}laakkonenc@gmail.com${normal}"
	echo
	echo 'Current Dev - askmeaboutloom: - Not yet provided'
	echo "     ${underline}https://github.com/askmeaboutlo0m${normal}"
	echo
	echo 'Script Creator - Bluestrings (Ko-Fi):'
	echo "     ${underline}https://ko-fi.com/bluestrings${normal}"
	echo
}

function drawpile_credits_urls_functions () {
	echo "Script Ver.	--> ${bold}$drawpile_script_version${normal}"
	echo "Google Doc 	--> ${underline}http://tinyurl.com/jx5oe4h ${normal}"
	echo "GitHub 		--> ${underline}https://github.com/$github_account_name/$github_project_name.git ${normal}"
}
echo
drawpile_credits_function
drawpile_credits_urls_functions
echo
pause
echo
echo '--------------------------------------------------------------------------------'
echo '--------------------------------------------------------------------------------'
echo
function language_check_and_verify_not_null_function () {
	# If value is null, check this value.
	lang=$( locale | grep LANGUAGE | cut -d= -f2 | cut -d_ -f1 )
	# echo "Value 01: $lang"
	if [ "$lang" == "" ]; then
		# If previous value is null, check this value instead.
		# Needed in Fedora (LANGUAGE not available), or if LANGUAGE= has nothing beside it.
		lang=$( locale | grep -m 1 LANG | cut -d= -f2 | cut -d_ -f1 )
		# echo "Value 02: $lang"
		if [ "$lang" == "" ]; then
			echo
			echo "${bold}${yellow}************************ POSSIBLE PROBLEM DETECTED *************************${normal}"
			echo 
			echo "${bold}${yellow}Unable to determine system language!${normal}"
			echo "${bold}${yellow}This may cause the script to not function properly!${normal}"
			echo
			echo "You may need to change your system's language in order for the script to"
			echo "     succeed. Certain prompts from text based utilities are checked"
			echo "     against English words, causing the script logic to fail in other"
			echo "     languages. A reboot of the system is required in most cases."
			echo "     "
			echo "${bold}${yellow}Pausing Script for 30 seconds . . . ${normal}"
			echo "     "
			echo "${bold}${yellow}************************ POSSIBLE PROBLEM DETECTED *************************${normal}"
			echo
			sleep 30
		fi
	fi
}

language_check_and_verify_not_null_function

if [ "$lang" == "en" ] || [ "$lang" == "C.UTF-8" ] || [ "$lang" == "" ]; then
	:
else
	echo
	echo "${bold}${red}***************************** PROBLEM DETECTED *****************************${normal}"
	echo 
	echo "${bold}${red}Not using English, currently using: $lang ${normal}"
	echo "${bold}${red}This will cause the script to not function properly!${normal}"
	echo
	echo "You'll need to change your system's language in order for the script to"
	echo "     succeed. Certain prompts from text based utilities are checked"
	echo "     against English words, causing the script logic to fail in other"
	echo "     languages. A reboot of the system is required in most cases."
	echo "     "
	# echo "Also, please check the user-dirs.dirs file to make sure it points at accurate"
	# echo "     folder names after reboot."
	# echo "sudo nano /home/USERNAME-HERE/.config/user-dirs.dirs"
	# Nevermind, the line doesn't appear necessary as it will still work, but just look mis-spelled for some reason... 
	echo "     "
	echo "${bold}${red}Exiting Script in 30 seconds . . . ${normal}"
	echo "     "
	echo "${bold}${red}***************************** PROBLEM DETECTED *****************************${normal}"
	echo
	sleep 30
	exit
fi
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
what_linux_name=$( cat /etc/*-release | grep -i "^NAME=" | awk '{$1=$1};1' )
what_linux_flavor=$( cat /etc/*-release | grep -i "PRETTY_NAME=" | awk '{$1=$1};1' )
what_architecture=$( hostnamectl | grep -i "Architecture" | awk '{$1=$1};1' )
# verify_if_this_is_raspbian_or_debian --> https://raspberrypi.stackexchange.com/questions/6974/how-can-i-determine-which-os-image-i-am-running
verify_if_this_is_raspbian_or_debian=$( cat /etc/rpi-issue 2>/dev/null | grep -i "Raspberry Pi" | awk '{ print $1 " " $2 }' )
verify_pi_model=$( cat /proc/cpuinfo | tr -d '\t' | grep -i "Model:" | awk '{for (i=2; i<NF; i++) printf $i " "; print $NF}' | sed 's/Rev.*//' )
# Samples Below WITHOUT editing content
# Raspberry Pi Zero W Rev 1.1
# Raspberry Pi 3 Model B Rev 1.2
# Raspberry Pi 4 Model B Rev 1.1
# Samples Below WITH edited content based on string above
# Raspberry Pi Zero W
# Raspberry Pi 3 Model B
# Raspberry Pi 4 Model B
# ----------------------------------------------------------------------------------
<<comment_EOF
# NOTES ON SYSTEM PACKAGE INSTALLERS
https://docs.fedoraproject.org/en-US/quick-docs/dnf-vs-apt/
https://www.redhat.com/sysadmin/dnf-apt-users
https://www.ubuntubuzz.com/2017/03/comparison-of-common-commands-ubuntu-ubuntu-apt-fedora-dnf.html
apt-get -q -y install					dnf -q -y install
apt-get -q -y update					dnf -q -y check-update
apt-get -q -y upgrade					dnf -q -y upgrade

https://www.techrepublic.com/article/linux-101-how-to-clean-the-dnf-and-apt-caches/
apt-get clean							dnf clean dbcache / sudo dnf clean all

Will need to edit entire queries that use this command, information is formatted differently
apt-cache policy PACKAGENAME			dnf info -q PACKAGENAME
apt-cache search PACKAGENAME			dnf search PACKAGENAME

Should not need added, only for Pi
apt-key adv --recv-keys --keyserver		

comment_EOF
# ----------------------------------------------------------------------------------
function check_root_or_sudo_access_function () {
	if [[ "$USER" = "root" ]] || [[ "$USER" = "Root" ]] || [[ "$USER" = "ROOT" ]] || [[ $EUID == 0 ]]; then
		# if [[ "$USER" = "root" || "$USER" = "Root" || "$USER" = "ROOT" || $EUID == 0 ]]; then
		running_as_root_check=true
		echo "     ${bold}${green}Script running as root.${normal}"
	else
		running_as_root_check=false
		sudo whoami
		root_available_check=$?
		if [ "$root_available_check" -eq "0" ]; then
			echo "     ${bold}${green}User has sudo access.${normal}"
		elif [ "$root_available_check" -eq "1" ]; then
			echo
			echo "${bold}${red}Please run script as root or user with sudoer access.${normal}"
			echo "Can try typing the following to login as root: su"
			echo "Then try running the script again."
			echo
			echo "${bold}${red}Exiting script in 30 seconds.${normal}"
			echo
			sleep 30
			exit
		else
			echo
			echo "${bold}${red}This message should not be visible.${normal}"
			echo "${bold}${red}Please run script as root or user with sudoer access.${normal}"
			echo "Can try typing the following to login as root: su"
			echo "Then try running the script again."
			echo
			echo "${bold}${red}Exiting script in 30 seconds.${normal}"
			echo
			sleep 30
			exit
		fi
	fi
	echo
}

function debian_update_check_online_working_function () {
	apt_sources_list=/etc/apt/sources.list
	if grep -q "^# deb cdrom:" $apt_sources_list; then
		echo "${invis}Debian CD-ROM entry is disabled.${normal}"
	elif grep -q "^deb cdrom:" $apt_sources_list; then
		#
		# Sources List 											--> 	https://wiki.debian.org/SourcesList
		# Chapter 9. Keeping your Debian system up-to-date		--> 	https://www.debian.org/doc/manuals/debian-faq/uptodate.en.html
		#
		echo "${bold}${red}Debian CD-ROM entry is enabled.${normal}"
		echo
		echo "Script may not function as intended. Please add a viable update"
		echo "mirror for use by clicking on activities, click on 'Type to search',"
		echo "type in 'Software', open 'Software & Updates', click on"
		echo "'Other Software', and paste in the links below. Make sure to"
		echo "disable the 'cdrom' option and click 'Close'."
		echo
		echo "${bold}${cyan}For US-based Users:${normal}"
		echo "deb http://ftp.us.debian.org/debian stable main contrib"
		echo
		echo "${bold}${cyan}Example sources.list for Debian 12 - Bookworm:${normal}"
		echo "deb http://deb.debian.org/debian bookworm main"
		echo "deb http://deb.debian.org/debian-security/ bookworm-security main"
		echo "deb http://deb.debian.org/debian bookworm-updates main"
		echo
		echo
		echo "${bold}${cyan}For other locations, consult the Debian Mirrors (worldwide) list:${normal}"
		echo "     https://www.debian.org/mirror/list"
		echo
		echo "${bold}${cyan}Re-director Service${normal}"
		echo "The Re-director service aims to solve the problem of choosing a Debian"
		echo "mirror. It uses the geographic location of the user and other information" 
		echo "to choose the best mirror that can serve the files."
		echo
		echo "deb http://httpredir.debian.org/debian stable main contrib"
		echo
		echo 
		echo "When you're ready, press any key to continue."
		echo
		pause
	else
		echo "${bold}${red}Message should not be visible for Debian.${normal}"
		echo "However I can't figure out better way to check if updates are"
		echo "enabled in Debian or not."
	fi
}

function debian_x86_64_vs_arm_function () {
	if [[ "$what_architecture" == "Architecture: arm64" || "$what_architecture" == "Architecture: arm" ]] && [ "$verify_if_this_is_raspbian_or_debian" == "Raspberry Pi" ]; then
		echo "${bold}${green}Running Raspbian on Raspberry Pi (arm or arm64 Processor).${normal}" 
	elif [ "$what_architecture" == "Architecture: x86-64" ]; then
		if [ "$verify_if_this_is_raspbian_or_debian" == "Raspberry Pi" ]; then
			echo "${bold}${green}Running Raspbian for Desktop (x86-64).${normal}"
		elif [ "$verify_if_this_is_raspbian_or_debian" == "" ]; then
			echo "${bold}${green}Running Debian (x86-64).${normal}"
			check_root_or_sudo_access_function
			debian_update_check_online_working_function
		else
			echo "${bold}${green}Unsure if running Debian or Raspbian for Desktop (x86-64).${normal}"
		fi
	elif [[ "$what_architecture" == "Architecture: arm64" || "$what_architecture" == "Architecture: arm" ]] && [ "$verify_if_this_is_raspbian_or_debian" != "Raspberry Pi" ]; then
		echo "${bold}${green}Running on an arm or arm64 Processor, but not using Raspbian.${normal}" 
	else
		echo "${bold}${red}Unable to identify architecture. Exiting script.${normal}"
		echo
		sleep 30
		exit
	fi
}

function apt_get_function () {
	# Used to verify if command apt is available and exit script if not.
	# Doing this three different ways in order to make sure the command
	# is absolutely available for use as the script depends on it working.
	command -v apt > /dev/null 2>&1 || type apt > /dev/null 2>&1 || hash apt 2>/dev/null || { echo >&2 "Script requires package apt but it's not installed. Exiting script in 30 seconds."; sleep 30; exit 1; }
	#
	package_install_program="apt-get -q -y install"
	packages_update_program="apt-get -q -y update"
	packages_system_upgrade="apt-get -q -y upgrade"
	packages_clean_program="apt-get clean"
	package_info_program="apt-cache policy"
}

function dnf_function () {
	package_install_program="dnf -q -y install"
	packages_update_program="dnf -q -y check-update"
	packages_system_upgrade="dnf -q -y upgrade"
	packages_clean_program="echo ${invis} Skipping 'dnf clean dbcache' ${normal}"
	package_info_program="dnf info -q"
}

function yum_function () {
	package_install_program="yum install -q -y"
	packages_update_program="yum check-update"
	packages_system_upgrade="yum upgrade"
	packages_clean_program="echo ${invis} Skipping 'yum clean dbcache' ${normal}"
	package_info_program="yum info"
}

function adduser_and_addgroup_function () {
	# Debian and Ubuntu
	user_add_program="adduser"
	# sudo $user_add_program $current_username drawpileread
	# sudo $user_add_program drawpileuser $user_add_options_program_01 $user_add_options_program_02
	group_add_program="addgroup"
	# sudo $group_add_program drawpileread
	user_add_options_program_01="-ingroup users"
	user_add_options_program_02="--gecos \"\""
	user_add_options_program_03="adduser drawpileuser drawpileread"
}

function useradd_and_groupadd_function () {
	# Fedora
	user_add_program="useradd"
	# sudo $user_add_program $current_username drawpileread
	# sudo $user_add_program drawpileuser $user_add_options_program_01 $user_add_options_program_02
	group_add_program="groupadd"
	# sudo $group_add_program drawpileread
	user_add_options_program_01="-g users"
	user_add_options_program_02=""
	user_add_options_program_03="usermod -a drawpileuser -G drawpileread"
	# sudo userdel drawpileuser
	# sudo rm -R /home/drawpileuser
	# sudo groupdel drawpileread
}

function fedora_end_of_life_function () {
	fedora_release_recommended=39
	fedora_release_minimum=38
	
	echo "${bold}${red}It is not recommended to continue without updating${normal}"
	echo "${bold}${red}to a new, supported version ($fedora_release_minimum or higher).${normal}"
	echo
	echo "${bold}${red}Version 33 at minimum should work with Drawpile Beta 2.2 server${normal}"
	echo "${bold}${red}as of 2023-09-16, though the latest version $fedora_release_recommended ${normal}"
	echo "${bold}${red}is recommended for security reasons. However, don't go up more than 2${normal}"
	echo "${bold}${red}versions at one time (it won't work). You may need to reboot again${normal}"
	echo "${bold}${red}after the update has completed. ${normal}"
	echo 
	echo "${bold}${white}${underline}https://docs.fedoraproject.org/en-US/releases/eol/${normal}"
	echo
	echo
	echo "${bold}${yellow}Use these commands to prep upgrade:${normal}"
	echo "     sudo dnf --refresh upgrade"
	echo "     sudo dnf install -y -q dnf-plugin-system-upgrade"
	echo "     sudo dnf system-upgrade download --releasever=$fedora_release_recommended" # echo "     sudo dnf system-upgrade download --releasever=32"
	echo
	echo "${bold}${yellow}Use this command to start upgrade:${normal}"
	echo "     sudo dnf system-upgrade reboot"
	echo
	echo "${bold}${yellow}Remove cached metadata and transaction:${normal}"
	echo "     dnf system-upgrade clean"
	echo "${bold}${yellow}Remove cached packages:${normal}"
	echo "     dnf clean packages"
	echo
	# Failing that, you may need to remove old kernels.
	# https://haydenjames.io/fix-least-xmb-space-needed-boot-filesystem/
	# df -h
	#
	# https://almalinux.discourse.group/t/cleaning-old-kernels-alternatives-to-package-cleanup-oldkernels/695
	# dnf remove $(dnf repoquery --installonly --latest-limit=-2 -q)
	echo "Waiting 30 seconds before continuing script."
	sleep 30
}
# ----------------------------------------------------------------------------------
function wget_or_wget2_non_fedora_function () {
	wget_or_wget2_quiet_progress="wget -q --show-progress"
	wget_or_wget2_quiet_progress_non_verbose="wget -nv"
	wget_or_wget2_no_check_certificate="wget --no-check-certificate"
}

function wget_or_wget2_fedora_function () {
	wget_or_wget2_quiet_progress="wget -q --force-progress"
}

wget_or_wget2_non_fedora_function

if [ "$what_linux_name" == "NAME=\"Debian GNU/Linux\"" ] || [ "$what_linux_name" == "NAME=\"Raspbian GNU/Linux\"" ]; then
	apt_get_function
	adduser_and_addgroup_function
	if [ "$what_linux_flavor" == "PRETTY_NAME=\"Debian GNU/Linux 9 (stretch)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Raspbian GNU/Linux 9 (stretch)\"" ]; then
		debian_x86_64_vs_arm_function
		echo "${bold}${green}Debian GNU/Linux 9 (stretch)${normal}"
	elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Debian GNU/Linux 10 (buster)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Raspbian GNU/Linux 10 (buster)\"" ]; then
		debian_x86_64_vs_arm_function
		echo "${bold}${green}Debian GNU/Linux 10 (buster)${normal}"
	elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Debian GNU/Linux 11 (bullseye)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Raspbian GNU/Linux 11 (bullseye)\"" ]; then
		debian_x86_64_vs_arm_function
		echo "${bold}${green}Debian GNU/Linux 11 (bullseye)${normal}"
	elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Debian GNU/Linux 12 (bookworm)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Raspbian GNU/Linux 12 (bookworm)\"" ]; then
		debian_x86_64_vs_arm_function
		echo "${bold}${green}Debian GNU/Linux 12 (bookworm)${normal}"
	else
		echo "${bold}${red}Unable to identify if supported. Exiting script.${normal}"
		echo
		echo "Linux Name         : $what_linux_name"
		echo "Linux Flavor       : $what_linux_flavor"
		echo "Architecture       : $what_architecture"
		echo "Raspbian or Debian : $verify_if_this_is_raspbian_or_debian"
		echo "Pi Model           : $verify_pi_model"
		echo
		sleep 30
		exit
	fi
elif [ "$what_linux_name" == "NAME=\"Ubuntu\"" ]; then
	apt_get_function
	adduser_and_addgroup_function
	if [ "$what_linux_flavor" == "PRETTY_NAME=\"Ubuntu 24.04.2 LTS\"" ]; then
		echo "${bold}${green}Running Ubuntu 24.04.2 LTS.${normal}"
	elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Ubuntu 24.04.1 LTS\"" ]; then
		echo "${bold}${green}Running Ubuntu 24.04.1 LTS.${normal}"
		elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Ubuntu 24.04 LTS\"" ]; then
		echo "${bold}${green}Running Ubuntu 24.04 LTS.${normal}"
	elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Ubuntu 22.04.4 LTS\"" ]; then
		echo "${bold}${green}Running Ubuntu 22.04.4 LTS.${normal}"
	elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Ubuntu 22.04.3 LTS\"" ]; then
		echo "${bold}${green}Running Ubuntu 22.04.3 LTS.${normal}"
	elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Ubuntu 22.04.2 LTS\"" ]; then
		echo "${bold}${green}Running Ubuntu 22.04.2 LTS.${normal}"
	elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Ubuntu 22.04.1 LTS\"" ]; then
		echo "${bold}${green}Running Ubuntu 22.04.1 LTS.${normal}"
	elif [ "$what_linux_name" == "NAME=\"Ubuntu\"" ]; then
		echo "${bold}${yellow}Running Ubuntu, version may not be supported.${normal}"
		echo
		echo "Linux Name         : $what_linux_name"
		echo "Linux Flavor       : $what_linux_flavor"
		echo "Architecture       : $what_architecture"
		echo
		sleep 30
	else
		echo "${bold}${red}Unable to identify if supported. Exiting script.${normal}"
		echo
		echo "Linux Name         : $what_linux_name"
		echo "Linux Flavor       : $what_linux_flavor"
		echo "Architecture       : $what_architecture"
		echo
		sleep 30
		exit
	fi	
elif [[ "$what_linux_name" == "NAME=\"Fedora Linux\"" || "$what_linux_name" == "NAME=Fedora" ]]; then
	# Was for Firewall-cmd which is currently commented out. 
	what_fedora_variant=$( cat /etc/*-release | grep -i "^VARIANT_ID" )
	#
	what_fedora_variant_name=$( cat /etc/*-release | grep -i "^VARIANT_ID" | cut -d "=" -f2 )
	
	if [ -z "$what_fedora_variant" ] || [ -z "$what_fedora_variant_name" ]; then
		# Values would be null because the VARIANT ID does not exist.
		if [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Server Edition)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Forty)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 41 (Server Edition)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 41 (Forty One)\"" ]; then
			what_fedora_variant="VARIANT_ID=server"
			what_fedora_variant_name="server"
		fi
	fi
	
	# dnf_function
	yum_function
	useradd_and_groupadd_function
	check_root_or_sudo_access_function	
	if [ "$what_fedora_variant_name" == "server" ]; then
		if [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 41 (Server Edition)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 41 (Forty One)\"" ]; then
			echo "${bold}${yellow}Running Fedora Server 41.${normal}" && echo "${bold}${yellow}Testing support now...${normal}"
			wget_or_wget2_fedora_function
		elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Server Edition)\"" ] || [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Forty)\"" ]; then
			echo "${bold}${green}Running Fedora Server 40.${normal}"
			
			# Replace wget with wget2 (a modern implementation of wget intended to replace wget 1.x) as the provider of wget.
			#      https://discussion.fedoraproject.org/t/f40-change-proposal-wget2-as-wget/96422/5
			# Developer of wget says wget2 should be used with wget, not in place of wget. Stupid idea of Fedora.
			#      https://github.com/rockdaboot/wget2/issues/314#issuecomment-2080858803
			wget_or_wget2_fedora_function
			
		elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 39 (Server Edition)\"" ]; then
			echo "${bold}${green}Running Fedora Server 39.${normal}"  && echo "${bold}${yellow}End of Life support is 2024-11-12.${normal}"
		elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 38 (Server Edition)\"" ]; then
			echo "${bold}${green}Running Fedora Server 38.${normal}" && echo && echo "${bold}${yellow}End of Life support is 2024-05-14.${normal}"
			fedora_end_of_life_function
		elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 37 (Server Edition)\"" ]; then
			echo "${bold}${green}Running Fedora Server 37.${normal}" && echo && echo "${bold}${yellow}End of Life support is 2023-11-14.${normal}"
			fedora_end_of_life_function
		elif [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 36 (Server Edition)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora 36 (Server Edition)\"" ]]; then
			echo "${bold}${red}Running Fedora Server 36.${normal}" && echo && echo "${bold}${red}End of Life support since 2023-05-16.${normal}"
			fedora_end_of_life_function
		elif [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 35 (Server Edition)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora 35 (Server Edition)\"" ]]; then
			echo "${bold}${red}Running Fedora Server 35.${normal}" && echo && echo "${bold}${red}End of Life support since 2022-12-13.${normal}"
			fedora_end_of_life_function
		elif [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 34 (Server Edition)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora 34 (Server Edition)\"" ]]; then
			echo "${bold}${red}Running Fedora Server 34.${normal}" && echo && echo "${bold}${red}End of Life support since 2022-06-07.${normal}"
			fedora_end_of_life_function
		elif [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 33 (Server Edition)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora 33 (Server Edition)\"" ]]; then
			echo "${bold}${red}Running Fedora Server 33.${normal}" && echo && echo "${bold}${red}End of Life support since 2021-11-30.${normal}"
			fedora_end_of_life_function
		elif [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 32 (Server Edition)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora 32 (Server Edition)\"" ]]; then
			echo "${bold}${red}Running Fedora Server 32.${normal}" && echo && echo "${bold}${red}End of Life support since 2021-05-25.${normal}"
			fedora_end_of_life_function
		elif [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 31 (Server Edition)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora 31 (Server Edition)\"" ]]; then
			echo "${bold}${red}Running Fedora Server 31.${normal}" && echo && echo "${bold}${red}End of Life support since 2020-11-24.${normal}"
			fedora_end_of_life_function
		elif [[ "$what_linux_name" == "NAME=\"Fedora Linux\"" || "$what_linux_name" == "NAME=Fedora" ]]; then
			echo "${bold}${yellow}Running Fedora Server, version may not be supported.${normal}"
			echo
			echo "Linux Name         : $what_linux_name"
			echo "Variant Name       : $what_fedora_variant_name"
			echo "Linux Flavor       : $what_linux_flavor"
			echo "Architecture       : $what_architecture"
			echo
			sleep 30
		else
			echo "This message shouldn't be visible to determine Fedora type (Server)."
		fi
	elif [ "$what_fedora_variant_name" == "workstation" ]; then
		if [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 41 (Workstation Edition)\"" ]; then
			echo "${bold}${yellow}Running Fedora Workstation 41.${normal}" && echo "${bold}${yellow}Testing support now...${normal}"
			wget_or_wget2_fedora_function
		elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Workstation Edition)\"" ]; then
			echo "${bold}${green}Running Fedora Workstation 40.${normal}"
			
			# Replace wget with wget2 (a modern implementation of wget intended to replace wget 1.x) as the provider of wget.
			#      https://discussion.fedoraproject.org/t/f40-change-proposal-wget2-as-wget/96422/5
			# Developer of wget says wget2 should be used with wget, not in place of wget. Stupid idea of Fedora.
			#      https://github.com/rockdaboot/wget2/issues/314#issuecomment-2080858803
			wget_or_wget2_fedora_function
		elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 39 (Workstation Edition)\"" ]; then
			echo "${bold}${yellow}Running Fedora Workstation 39.${normal}"
		elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 38 (Workstation Edition)\"" ]; then
			echo "${bold}${green}Running Fedora Workstation 38.${normal}"
		elif [[ "$what_linux_name" == "NAME=\"Fedora Linux\"" || "$what_linux_name" == "NAME=Fedora" ]]; then
			echo "${bold}${yellow}Running Fedora Workstation, version may not be supported.${normal}"
			echo
			echo "Linux Name         : $what_linux_name"
			echo "Variant Name       : $what_fedora_variant_name"
			echo "Linux Flavor       : $what_linux_flavor"
			echo "Architecture       : $what_architecture"
			echo
			sleep 30
		else
			echo "This message shouldn't be visible to determine Fedora type (Workstation)."
		fi
	elif [[ "$what_linux_name" == "NAME=\"Fedora Linux\"" || "$what_linux_name" == "NAME=Fedora" ]]; then
		echo "${bold}${yellow}Running Fedora, version may not be supported.${normal}"
		echo
		echo "Linux Name         : $what_linux_name"
		echo "Variant Name       : $what_fedora_variant_name"
		echo "Linux Flavor       : $what_linux_flavor"
		echo "Architecture       : $what_architecture"
		echo
		sleep 30
	else
		echo "${bold}${red}Unable to identify if supported system. Exiting script.${normal}"
		echo
		echo "Linux Name         : $what_linux_name"
		echo "Linux Flavor       : $what_linux_flavor"
		echo "Architecture       : $what_architecture"
		echo
		sleep 30
		exit
	fi
else
	echo "${bold}${red}Unable to identify if supported system. Exiting script.${normal}"
	echo
	echo "Linux Name         : $what_linux_name"
	echo "Linux Flavor       : $what_linux_flavor"
	echo "Architecture       : $what_architecture"
	echo "Raspbian or Debian : $verify_if_this_is_raspbian_or_debian"
	echo "Pi Model           : $verify_pi_model"
	echo
	sleep 30
	exit
fi

# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
# 
# Used to verify if command sudo is available and warn if not.
# Will warn user to run as root if sudo is not available.
#
# Doing this three different ways in order to make sure the command
# is absolutely available for use as the script depends on it working.
#

[[ "$USER" = "root" ]] || [[ "$USER" = "Root" ]] || [[ "$USER" = "ROOT" ]] || command -v sudo > /dev/null 2>&1 || type sudo > /dev/null 2>&1 || hash sudo 2>/dev/null || { echo >&2 "Script requires sudo or root access. Exiting script in 30 seconds."; sleep 30; exit 1; }

# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------

function read_stored_config_value_query_function () {
	read_stored_config_value_query_null_check=0
	read_stored_config_value_query_1=$( grep -m 1 "$variable_to_read_1 = " "$drawpile_configuration_values_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )
	[ -z "$variable_to_read_2" ] || read_stored_config_value_query_2=$( grep -m 1 "$variable_to_read_2 = " "$drawpile_configuration_values_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )
	[ -z "$variable_to_read_3" ] || read_stored_config_value_query_3=$( grep -m 1 "$variable_to_read_3 = " "$drawpile_configuration_values_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )
	
	if [ -z "$read_stored_config_value_query_1" ] || [ "$read_stored_config_value_query_1" = "=" ]; then
		read_stored_config_value_query_null_check=1
		# If variable cannot be found in drawpile configuration values file, check app installation status. Only when value is null or = sign.
		read_stored_config_value_query_1=$( grep -m 1 "$variable_to_read_1 = " "$app_installation_status_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )
		[ -z "$variable_to_read_2" ] || read_stored_config_value_query_2=$( grep -m 1 "$variable_to_read_2 = " "$app_installation_status_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )
		[ -z "$variable_to_read_3" ] || read_stored_config_value_query_3=$( grep -m 1 "$variable_to_read_3 = " "$app_installation_status_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )
	fi
	
	if [ -z "$read_stored_config_value_query_1" ] || [ "$read_stored_config_value_query_1" = "=" ]; then
		if [ "$read_stored_config_value_query_null_check" = "0" ]; then
			echo "No value read from file: $drawpile_configuration_values_file"
			echo
		elif [ "$read_stored_config_value_query_null_check" = "1" ]; then
			echo "No value read from files: $drawpile_configuration_values_file"
			echo "                          $app_installation_status_file"
			echo
		else
			echo "This message should not be visible for: read_stored_config_value_query_null_check"
		fi
		# Force user to insert proper data this way without having to check for null variable.
		maybe_use_config_value=no
	else
		echo "${green}Value located:${normal} $read_stored_config_value_query_1"
		echo
		[ -z "$value_description_1" ] || echo "$value_description_1"
		[ -z "$value_description_2" ] || echo "$value_description_2"
		[ -z "$value_description_3" ] || echo "$value_description_3"
		[ -z "$value_description_4" ] || echo "$value_description_4"
		[ -z "$value_description_5" ] || echo "$value_description_5"
		[ -z "$value_description_6" ] || echo "$value_description_6"
		[ -z "$value_description_7" ] || echo "$value_description_7"
		[ -z "$value_description_8" ] || echo "$value_description_8"
		[ -z "$value_description_9" ] || echo "$value_description_9"
		[ -z "$value_description_10" ] || echo "$value_description_10"
		[ -z "$value_description_11" ] || echo "$value_description_11"
		[ -z "$value_description_12" ] || echo "$value_description_12"
		[ -z "$value_description_13" ] || echo "$value_description_13"
		[ -z "$value_description_14" ] || echo "$value_description_14"
		[ -z "$value_description_15" ] || echo "$value_description_15"
		[ -z "$value_description_16" ] || echo "$value_description_16"
		[ -z "$value_description_17" ] || echo "$value_description_17"
		[ -z "$value_description_18" ] || echo "$value_description_18"
		[ -z "$value_description_19" ] || echo "$value_description_19"
		[ -z "$value_description_20" ] || echo "$value_description_20"
		[ -z "$value_description_21" ] || echo "$value_description_21"
		[ -z "$value_description_22" ] || echo "$value_description_22"
		[ -z "$value_description_23" ] || echo "$value_description_23"
		[ -z "$value_description_24" ] || echo "$value_description_24"
		[ -z "$value_description_25" ] || echo "$value_description_25"
		[ -z "$value_description_26" ] || echo "$value_description_26"
		[ -z "$value_description_27" ] || echo "$value_description_27"
		[ -z "$value_description_28" ] || echo "$value_description_28"
		[ -z "$value_description_29" ] || echo "$value_description_29"
		[ -z "$value_description_30" ] || echo "$value_description_30"
		[ -z "$value_description_1" ] || echo
		[ -z "$variable_to_read_2" ] || echo "Query 02: $read_stored_config_value_query_2"
		[ -z "$variable_to_read_2" ] || echo
		[ -z "$variable_to_read_3" ] || echo "Query 03: $read_stored_config_value_query_3"
		[ -z "$variable_to_read_3" ] || echo
		while :; do
			read -r -p "${bold}${cyan}Would you like to use this value again? (Y)es or (N)o:${normal} " maybe_use_config_value
			echo
			if [ "$maybe_use_config_value" == "y" ] || [ "$maybe_use_config_value" == "Y" ] || [ "$maybe_use_config_value" == "yes" ] || [ "$maybe_use_config_value" == "YES" ] || [ "$maybe_use_config_value" == "Yes" ] || [ "$maybe_use_config_value" == "n" ] || [ "$maybe_use_config_value" == "N" ] || [ "$maybe_use_config_value" == "no" ] || [ "$maybe_use_config_value" == "NO" ] || [ "$maybe_use_config_value" == "No" ]; then
				break
			else
				echo
				echo "${bold}${red}Invalid input selection, try again.${normal}"
				echo
				echo ----------------------------------------------------------------------------------
				echo
			fi
		done
	fi
	variable_to_read_2=""
	variable_to_read_3=""
	
	value_description_1=""
	value_description_2=""
	value_description_3=""
	value_description_4=""
	value_description_5=""
	value_description_6=""
	value_description_7=""
	value_description_8=""
	value_description_9=""
	value_description_10=""
	value_description_11=""
	value_description_12=""
	value_description_13=""
	value_description_14=""
	value_description_15=""
	value_description_16=""
	value_description_17=""
	value_description_18=""
	value_description_19=""
	value_description_20=""
	value_description_21=""
	value_description_22=""
	value_description_23=""
	value_description_24=""
	value_description_25=""
	value_description_26=""
	value_description_27=""
	value_description_28=""
	value_description_29=""
	value_description_30=""
}

# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
function select_non_root_account () {
	echo
	echo '--------------------------------------------------------------------------------'
	echo '--------------------------------------------------------------------------------'
	echo
	variable_to_read_1="current_username"
	variable_to_read_2=""
	variable_to_read_3=""

	value_description_1="When running script with sudo or su, your user account should be specified"
	value_description_2="because portions of the script require things to run without root access,"
	value_description_3="adds your user to be able to read Drawpile files, and/or creates shortcuts"
	value_description_4="if you have a desktop environment."
	value_description_5=""

	read_stored_config_value_query_function
	if [ "$maybe_use_config_value" == "y" ] || [ "$maybe_use_config_value" == "Y" ] || [ "$maybe_use_config_value" == "yes" ] || [ "$maybe_use_config_value" == "YES" ] || [ "$maybe_use_config_value" == "Yes" ]; then
		echo "Storing value and moving on."
		current_username=$read_stored_config_value_query_1
	elif [ "$maybe_use_config_value" == "n" ] || [ "$maybe_use_config_value" == "N" ] || [ "$maybe_use_config_value" == "no" ] || [ "$maybe_use_config_value" == "NO" ] || [ "$maybe_use_config_value" == "No" ]; then
		echo "When running script with sudo or su, please specify your user account name"
		echo "with a valid user directory indicated below." 
		echo
		echo "${bold}${cyan}Note:${normal} Portions of the script do require some things to run without root access."
		echo "     Also, if you are running a graphical user interface with your setup,"
		echo "     prefer YOUR user account over selecting drawpileuser or root. This"
		echo "     enables shortcut creation on your desktop for server tools."
		echo
		echo "${bold}${underline}Generating list of system users (may take up to a minute or so):${normal}"
		id -nu 0
		eval getent passwd {$(awk '/^UID_MIN/ {print $2}' /etc/login.defs)..$(awk '/^UID_MAX/ {print $2}' /etc/login.defs)} | cut -d: -f1
		echo
		echo "${bold}${underline}Here are a list of folders in the home directory:${normal}"
		ls -d /home/*/
		echo
		read -r -p "${bold}${cyan}Enter ONLY the username:${normal} " current_username
		echo
		while [[ ! -e "/home/$current_username" ]]
		do
			echo '--------------------------------------------------------------------------------'
			echo
			echo "${bold}${red}Invalid user name entered (no matching home directory). Please ${normal}"
			echo "${bold}${red}enter a valid user name with a user directory indicated below:${normal}"
			ls -d /home/*/
			echo
			read -r -p "${bold}${cyan}Enter user name:${normal} " current_username
			echo
		done
		sudo sed -i '\!^current_username =!{h;s!=.*!= '"$current_username"'!};${x;\!^$!{s!!current_username = '"$current_username"'!;H};x}' $drawpile_configuration_values_file
	else
		echo "This message should not be visible."
	fi
}

# Prompt for user name change if root detected, first attempting Pi (and verifying), 
#     and requesting user input with verification directory exists.

if [[ "$USER" = "root" ]] || [[ "$USER" = "Root" ]] || [[ "$USER" = "ROOT" ]]; then
	current_username=pi
	if [[ -e "/home/$current_username" ]]; then
		# Do nothing as no error was detected. Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
		:
	else
		select_non_root_account
	fi
else
	current_username=$USER
	echo "Current user: $current_username"
fi

drawpileuser_username_id="$( id -u drawpileuser )"
current_username_id="$( id -u $current_username )"

if [ "$drawpileread_test" == "yes" ]; then
	# Do nothing, no action required
	:
elif [ "$drawpileread_test" == "no" ]; then
	if [[ "$what_linux_name" != "NAME=\"Fedora Linux\"" && "$what_linux_name" != "NAME=Fedora" ]]; then
		sudo $user_add_program $current_username drawpileread
	fi
	if [[ "$what_linux_name" == "NAME=\"Fedora Linux\"" || "$what_linux_name" == "NAME=Fedora" ]]; then
		sudo usermod -a $current_username -G drawpileread
	fi
fi

echo
echo '--------------------------------------------------------------------------------'
echo '--------------------------------------------------------------------------------'
echo

InvalidPathText="${red}${bold}X - Automatic local path selection is invalid -${normal}"
script_created_location_sessions="Programs/Drawpile-Srv-Files/sessions"
script_created_location_server_scripts="Programs/Drawpile-Srv-Files/server-scripts"

dp_install_loc=$( grep -m 1 "dp_install_loc = " "$drawpile_configuration_values_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )
# Comment out the above line and use line below for custom location if testing.
#dp_install_loc=/home/$USER/Public/sessions-2024-05


if [ -z "$dp_install_loc" ] || [ "$dp_install_loc" = "=" ]; then
	dp_install_loc_9_custom=$( grep -m 1 "dp_install_loc_9_custom = " "$drawpile_configuration_values_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )

	local_user_dirs="/home/$current_username/.config/user-dirs.dirs"

	if [[ -e "$local_user_dirs" ]]; then
		XDG_PUBLICSHARE_DIR=$( grep -m 1 "XDG_PUBLICSHARE_DIR=" "$local_user_dirs" | cut -d "=" -f2- | sed s/"\$HOME\/"// | sed -e 's/^"//' -e 's/"$//' )
		XDG_DESKTOP_DIR=$( grep -m 1 "XDG_DESKTOP_DIR=" "$local_user_dirs" | cut -d "=" -f2- | sed s/"\$HOME\/"// | sed -e 's/^"//' -e 's/"$//' )
		XDG_DOCUMENTS_DIR=$( grep -m 1 "XDG_DOCUMENTS_DIR=" "$local_user_dirs" | cut -d "=" -f2- | sed s/"\$HOME\/"// | sed -e 's/^"//' -e 's/"$//' )
		XDG_PICTURES_DIR=$( grep -m 1 "XDG_PICTURES_DIR=" "$local_user_dirs" | cut -d "=" -f2- | sed s/"\$HOME\/"// | sed -e 's/^"//' -e 's/"$//' )
		
		XDG_MUSIC_DIR=$( grep -m 1 "XDG_MUSIC_DIR=" "$local_user_dirs" | cut -d "=" -f2- | sed s/"\$HOME\/"// | sed -e 's/^"//' -e 's/"$//' )
		XDG_VIDEOS_DIR=$( grep -m 1 "XDG_VIDEOS_DIR=" "$local_user_dirs" | cut -d "=" -f2- | sed s/"\$HOME\/"// | sed -e 's/^"//' -e 's/"$//' )
		XDG_DOWNLOAD_DIR=$( grep -m 1 "XDG_DOWNLOAD_DIR=" "$local_user_dirs" | cut -d "=" -f2- | sed s/"\$HOME\/"// | sed -e 's/^"//' -e 's/"$//' )
		
		option_loc_1="/home/$current_username/$XDG_PUBLICSHARE_DIR"
		option_loc_2="/home/$current_username/$XDG_DESKTOP_DIR"
		option_loc_3="/home/$current_username/$XDG_DOCUMENTS_DIR"
		option_loc_4="/home/$current_username/$XDG_PICTURES_DIR"
		option_loc_5="/usr/local/bin"
		option_loc_6="/home/drawpileuser"

		# The locations below are used with Samba file sharing set up.
		option_loc_10="/home/$current_username/$XDG_MUSIC_DIR"
		option_loc_11="/home/$current_username/$XDG_VIDEOS_DIR"
		option_loc_12="/home/$current_username/$XDG_DOWNLOAD_DIR"
	else
		option_loc_1="/home/$current_username/Public"
		option_loc_2="/home/$current_username/Desktop"
		option_loc_3="/home/$current_username/Documents"
		option_loc_4="/home/$current_username/Pictures"
		option_loc_5="/usr/local/bin"
		option_loc_6="/home/drawpileuser"

		# The locations below are used with Samba file sharing set up.
		option_loc_10="/home/$current_username/Music"
		option_loc_11="/home/$current_username/Videos"
		option_loc_12="/home/$current_username/Downloads"
	fi
else
	#  echo "Located install location $dp_install_loc"
	# Do nothing as no error was detected.
	# Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
	:
fi

function DisplayLocationSelectionOptions {
	echo
	echo "${bold}Script to search for Session Recordings and easily copy matches into another folder.${normal}"
	echo
	echo 'Enter a location where Drawpile Server contains session recordings.'
	echo 'This will be the location that will be searched.'
	echo
	echo ' - Specify an already existing location: simply enter the exact location'
	echo '        desired without a / at the end. This is an advanced option and not'
	echo '        suggested for average users. If using a path with spaces, do NOT '
	echo '        use double or single quotes as the script will not work if you do.'
	echo '        This directory must already exist.'
	echo
	echo "      ${underline}Acceptable Example:${normal} /home/$current_username/Desktop/My Drawpile Server/sessions"
	echo "	${underline}Note:${normal} This location is an example and may not exist on your computer."
	echo
}

function InvalidPathSelection01 () {
	echo
	echo "${red}${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}"
	echo "${red}${bold}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${normal}"
	echo "${red}${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}"
	echo
	echo "${red}${bold}Invalid path selection does not exist, try again. ${normal}"
	echo
	echo "${red}${bold}If selecting a path, simply enter the exact location desired without a / at${normal}"
	echo "${red}${bold}        the end. If using a path with spaces, do NOT use double or single ${normal}"
	echo "${red}${bold}        quotes as the script will not work if you do. This directory must${normal}"
	echo "${red}${bold}        already exist.${normal}"
	echo
	echo "${red}${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}"
	echo "${red}${bold}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${normal}"
	echo "${red}${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}"
	echo 
}

function AutoSelectLocation {
	echo
	if [[ -d "$dp_install_loc/$script_created_location_sessions" ]] ; then
		dp_install_loc_sessions=$dp_install_loc/$script_created_location_sessions
		echo "${bold}${green}Install location detected automatically:${normal} $dp_install_loc_sessions"
	elif [[ -d "$dp_install_loc" ]] ; then
		dp_install_loc_sessions=$dp_install_loc
		echo "${bold}${green}Install location detected automatically:${normal} $dp_install_loc_sessions"
	elif [[ -d "$option_loc_1/$script_created_location_sessions" ]] ; then
		dp_install_loc_sessions=$option_loc_1/$script_created_location_sessions
		echo "${bold}${green}Install location detected automatically:${normal} $dp_install_loc_sessions"
	elif [[ -d "$option_loc_2/$script_created_location_sessions" ]] ; then
		dp_install_loc_sessions=$option_loc_2/$script_created_location_sessions
		echo "${bold}${green}Install location detected automatically:${normal} $dp_install_loc_sessions"
	elif [[ -d "$option_loc_3/$script_created_location_sessions" ]] ; then
		dp_install_loc_sessions=$option_loc_3/$script_created_location_sessions
		echo "${bold}${green}Install location detected automatically:${normal} $dp_install_loc_sessions"
	elif [[ -d "$option_loc_4/$script_created_location_sessions" ]] ; then
		dp_install_loc_sessions=$option_loc_4/$script_created_location_sessions
		echo "${bold}${green}Install location detected automatically:${normal} $dp_install_loc_sessions"
	elif [[ -d "$option_loc_5/$script_created_location_sessions" ]] ; then
		dp_install_loc_sessions=$option_loc_5/$script_created_location_sessions
		echo "${bold}${green}Install location detected automatically:${normal} $dp_install_loc_sessions"
	elif [[ -d "$option_loc_6/$script_created_location_sessions" ]] ; then
		dp_install_loc_sessions=$option_loc_6/$script_created_location_sessions
		echo "${bold}${green}Install location detected automatically:${normal} $dp_install_loc_sessions"
	else
		echo "${bold}${red}Unable to find sessions folder under Public, Desktop, Documents, or Pictures folders.${normal}"
		echo
		echo $option_loc_1
		echo $option_loc_2
		echo $option_loc_3
		echo $option_loc_4
		echo $option_loc_5
		echo $option_loc_6
		echo
		DisplayLocationSelectionOptions
		while :; do
			read -p "${bold}Please enter the folder path:${normal} " dp_install_loc_sessions
			[[ -d "$dp_install_loc_sessions" ]] || { InvalidPathSelection01; DisplayLocationSelectionOptions; continue; }
			if [[ -d "$dp_install_loc_sessions" ]] ; then
				break
			else
				InvalidPathSelection01
				DisplayLocationSelectionOptions
			fi
		done
	fi
}

AutoSelectLocation

echo
echo '--------------------------------------------------------------------------------'
echo '--------------------------------------------------------------------------------'
echo
echo "${bold}${cyan}*****Auto Verifying if Script is Up to Date . . .*****${normal}"
echo
function script_update_check_function () {
	sudo mkdir -p -v "$dp_install_loc/Programs"
	sudo chown :drawpileread "$dp_install_loc/Programs"
	cd "$dp_install_loc/Programs" || { echo "Failure to change directory, exiting script in 30 seconds."; sleep 30; exit 1; }
	sudo $wget_or_wget2_quiet_progress "https://raw.githubusercontent.com/$github_account_name/$github_project_name/master/$github_main_script_only_sub_folder_path$script_name" || { echo "${bold}${red}If the server cannot reach the web, then this script will fail to run.${normal}"; echo ""; echo "Terminating script in 30 seconds."; echo ""; sleep 30; exit; }
	sudo chmod 777 "$dp_install_loc/Programs" -R
	# --------------------------------------------------------------------------------
	# The purpose of this check is for compatibility with older version of the scripts. 
	dpcheckversion=$(grep -m 1 "drawpilescriptversion=" "$dp_install_loc/Programs/$script_name" | cut -c 23-40)
	dp_check_version=$(grep -m 1 "drawpile_script_version=" "$dp_install_loc/Programs/$script_name" | cut -c 25-40)
	# This is a check in case the user changed the name of the script from the default, so it overwrites it successfully.
	current_script_name="$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")"
	echo

	if [[ "$dpcheckversion" != "" ]]; then
		dp_check_version=$dpcheckversion
	elif [[ "$dp_check_version" != "" ]]; then
		:
		# Do nothing as no error was detected.
		# Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
	else
		echo
		echo This update test should not be visible.
		echo
	fi
	# --------------------------------------------------------------------------------
	if [[ "$drawpile_script_version" < "$dp_check_version" ]]; then
		validate_script_download_complete=$( tail -10 "$dp_install_loc/Programs/$script_name" | grep -io -m 1 '} # this ensures the entire script is downloaded, the other part of this is located just after the script update and wget check. #' )
		if [[ "$validate_script_download_complete" == '} # this ensures the entire script is downloaded, the other part of this is located just after the script update and wget check. #' ]]; then
			# Do nothing, entire file is present presumably.
			echo "${bold}${green}Verified that the download of updated script is successful.${normal}"
			echo
		else
			echo "${bold}${yellow}Newest Script is using version $dp_check_version.${normal}"
			echo "${bold}${red}However, download of updated script failed. Removing file and exiting script.${normal}"
			echo
			echo "Please try running the script again to re-attempt the download."
			echo
			sudo rm -rf "$dp_install_loc/Programs/$script_name"
			pause
			exit
		fi
		echo "${bold}${yellow}Newest Script is using version $dp_check_version.${normal}"
		echo "Newer version of script available, the old script has been copied over"
		echo "the old script. Please re-run this script to use the newest version."
		echo
		cd "$dp_install_loc" || { echo "Failure to change directory, exiting script in 30 seconds."; sleep 30; exit 1; }
		sudo rm -rf "$script_directory/$current_script_name"
		sudo cp "$dp_install_loc/Programs/$script_name" "$script_directory/$current_script_name"
		wait $!
		sudo chmod 777 "$script_directory/$current_script_name"
		wait $!
		sudo rm -rf "$dp_install_loc/Programs/$script_name"
		echo
		echo "Terminating script in 30 seconds."
		echo
		sleep 30
		exit
	elif [[ "$drawpile_script_version" = "$dp_check_version" ]]; then
		echo "${bold}${green}Script is newest version available.${normal}"
		sudo rm -rf "$dp_install_loc/Programs/$script_name"
	elif [[ "$drawpile_script_version" > "$dp_check_version" ]]; then
		echo "${bold}${yellow}It appears the creator of the script has failed to update github with the newest version.${normal}"
		echo "Please reach on github or reach out to Bluestrings on the official Drawpile Discord"
		echo "server. Invite link is found on the lower left corner of the website."
		echo
		echo "Script in use: $drawpile_script_version"
		echo "Github Script: $dp_check_version"
		sudo rm -rf "$dp_install_loc/Programs/$script_name"
		echo
		echo "Pausing script for 5 seconds before continuing."
		echo
		sleep 5s
	else
		echo "${bold}${red}Unable to determine script version, proceeding with script.${normal}"
	fi
}

# if [ "$what_linux_flavor" != "PRETTY_NAME=\"Fedora Linux 40 (Server Edition)\"" ]; then

# ----------------------------------------------------------------------------------
# Verify wget is installed.
# ----------------------------------------------------------------------------------
if [[ "$what_linux_name" != "NAME=\"Fedora Linux\"" && "$what_linux_name" != "NAME=Fedora" ]]; then
	version_wget=$( apt-cache policy wget | grep "Installed:" | cut -c 14-19 )
	minimum_version_wget=1.18-5
elif [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Server Edition)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Forty)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Workstation Edition)\"" ]] || [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 41 (Server Edition)\"" ]] || [[ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 41 (Forty One)\"" || "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 41 (Workstation Edition)\"" ]]; then
	# elif [ "$what_linux_flavor" == "PRETTY_NAME=\"Fedora Linux 40 (Workstation Edition)\"" ]; then
	version_wget=$( dnf info -q wget2 | grep -i "Version" | tail -1 | tr -s " " | awk '{ print $3 }' )
	installation_status_wget=$( dnf info -q wget2 | sed -n '2 p' )
	if [[ "${installation_status_wget,,}" == "installed packages" || "${installation_status_wget,,}" == "available packages" ]]; then
		# Do nothing as no error was detected. Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
		:
	else
		installation_status_wget=$( dnf info -q wget2 | sed -n '1 p' )
		if [[ "${installation_status_wget,,}" == "installed packages" || "${installation_status_wget,,}" == "available packages" ]]; then
			# Do nothing as no error was detected. Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
			:
		else
			installation_status_wget="error"
		fi
	fi
	minimum_version_wget=2.1.0
elif [[ "$what_linux_name" == "NAME=\"Fedora Linux\"" || "$what_linux_name" == "NAME=Fedora" ]]; then
	version_wget=$( dnf info -q wget | grep -i "Version" | tail -1 | tr -s " " | awk '{ print $3 }' )
	installation_status_wget=$( dnf info -q wget | sed -n '2 p' )
	if [[ "${installation_status_wget,,}" == "installed packages" || "${installation_status_wget,,}" == "available packages" ]]; then
		# Do nothing as no error was detected. Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
		:
	else
		installation_status_wget=$( dnf info -q wget | sed -n '1 p' )
		if [[ "${installation_status_wget,,}" == "installed packages" || "${installation_status_wget,,}" == "available packages" ]]; then
			# Do nothing as no error was detected. Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
			:
		else
			installation_status_wget="error"
		fi
	fi
	minimum_version_wget=1.18-5
	# Installed Packages
	# Available Packages
	# Error: No matching Packages to list
else
	# Uses the same as first command, just in case.
	# --> if [[ "$what_linux_name" != "NAME=\"Fedora Linux\"" && "$what_linux_name" != "NAME=Fedora" ]]; then
	version_wget=$( apt-cache policy wget | grep "Installed:" | cut -c 14-19 )
	minimum_version_wget=1.18-5
fi

if [[ "$version_wget" = "(none)" ]] || [[ "$installation_status_wget" = "Available Packages" ]]; then
	echo "Package ${bold}wget${normal} is not installed."
	echo "Installing package, used for verifying script is"
	echo "up to date."
	echo
	sudo $packages_update_program
	sudo $package_install_program wget # || echo "" && echo "${bold}${red}Installation failed.${normal}" && echo "Exiting script..." && echo "" && sleep 30 && exit
	echo
	if [[ "$version_wget" = "(none)" ]] || [[ "$installation_status_wget" = "Error: No matching Packages to list" ]]; then
		echo "${bold}${red}Package wget is not available in your distribution's repository.${normal}"
		echo
		echo "This is an optional package used to verify that the script"
		echo "is up to date. You must manually check GitHub to verify"
		echo "the script being used is up to date. You may experience"
		echo "problems installing Drawpile if not up to date."
		echo
		echo "https://github.com/$github_account_name/$github_project_name"
		echo 
		echo "Continuing script in 30 seconds."
		echo
		echo
		sleep 30
	elif [[ "$version_wget" > "$minimum_version_wget" ]] || [[ "$version_wget" = "$minimum_version_wget" ]]; then
		script_update_check_function
	elif [[ "$version_wget" < "$minimum_version_wget" ]]; then
		echo "${bold}${yellow}Package wget is not the minimum version ($minimum_version_wget)${normal}."
		echo
		echo "This is an optional package used to verify that the script"
		echo "is up to date. Script may not work as intended."
		echo
		echo "You should manually check GitHub to verify the script being"
		echo "used is up to date. You may experience problems installing"
		echo "Drawpile if not up to date."
		echo
		echo "https://github.com/$github_account_name/$github_project_name"
		echo 
		echo "Continuing script in 30 seconds."
		echo
		echo
		sleep 30
		echo
		script_update_check_function
	else
		echo "Unable to make a determination of which version of wget is installed."
		echo "This message should not be visible."
	fi
elif [[ "$version_wget" > "$minimum_version_wget" ]] || [[ "$version_wget" = "$minimum_version_wget" ]]; then
	script_update_check_function
elif [[ "$version_wget" < "$minimum_version_wget" ]]; then
	echo "${bold}${yellow}Package wget is not the minimum version ($minimum_version_wget)${normal}."
	echo
	echo "This is an optional package used to verify that the script"
	echo "is up to date. Attempting to update."
	echo
	sudo $packages_update_program
	sudo $package_install_program wget # || echo "" && echo "${bold}${red}Installation failed.${normal}" && echo "Exiting script..." && echo "" && sleep 30 && exit
	echo
	if [[ "$version_wget" > "$minimum_version_wget" ]] || [[ "$version_wget" = "$minimum_version_wget" ]]; then
		echo
		script_update_check_function
	elif [[ "$version_wget" < "$minimum_version_wget" ]]; then
		echo "${bold}${yellow}Package wget is not the minimum version ($minimum_version_wget)${normal}."
		echo
		echo "This is an optional package used to verify that the script"
		echo "is up to date. Script may not work as intended since updated"
		echo "version is not available for install."
		echo
		echo "You should manually check GitHub to verify the script being"
		echo "used is up to date. You may experience problems installing"
		echo "Drawpile if not up to date."
		echo
		echo "https://github.com/$github_account_name/$github_project_name"
		echo 
		echo "Continuing script in 30 seconds."
		echo
		echo
		sleep 30
		echo
		script_update_check_function
	else
		echo "Unable to make a determination of which version of wget is installed."
		echo "This message should not be visible."
	fi
else
	echo "Unable to make a determination of which version of wget is installed."
	echo "This message should not be visible."
fi
# else
#	script_update_check_function
# fi

{ # this ensures the entire script is downloaded, other part is at very end of script #

# Version 1.0 - https://github.com/drawpile/Drawpile/commit/8974436285d5692bfc469c4ce4f77a3d0e87f98d
# Version 1.1 - https://github.com/drawpile/Drawpile/commit/f77dd391080d0c1d6a37048cb72e8ccbf7166a8c
purge_sessions_current_version=1.1
if [[ ! -e "$dp_install_loc/$script_created_location_server_scripts/purge-sessions" ]]; then
	sudo $wget_or_wget2_quiet_progress https://raw.githubusercontent.com/drawpile/Drawpile/main/src/thinsrv/contrib/purge-sessions -O "$dp_install_loc/$script_created_location_server_scripts/purge-sessions"
	sudo chmod 777 "$dp_install_loc/$script_created_location_server_scripts/purge-sessions"
	purge_sessions_version="$purge_sessions_current_version"
	sudo sed -i '\!^purge_sessions_version =!{h;s!=.*!= '"$purge_sessions_version"'!};${x;\!^$!{s!!purge_sessions_version = '"$purge_sessions_version"'!;H};x}' $drawpile_configuration_values_file
	if [[ "$what_linux_name" == "NAME=\"Fedora Linux\"" || "$what_linux_name" == "NAME=Fedora" ]]; then
		echo "Package perl-JSON-PP needed to run script for deleting old archives..."
		sleep 5
		sudo $package_install_program perl-JSON-PP
	fi
else
	if [[ -e "$dp_install_loc/$script_created_location_server_scripts/purge-sessions" ]]; then
		purge_sessions_version=$( grep -m 1 "purge_sessions_version = " "$drawpile_configuration_values_file" | awk '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )
		if [[ "$purge_sessions_version" < "$purge_sessions_current_version" ]]; then
			echo "The ./purge-sessions script is not up to date. Redownloading."
			sudo $wget_or_wget2_quiet_progress https://raw.githubusercontent.com/drawpile/Drawpile/main/src/thinsrv/contrib/purge-sessions -O "$dp_install_loc/$script_created_location_server_scripts/purge-sessions"
			sudo chmod 777 "$dp_install_loc/$script_created_location_server_scripts/purge-sessions"
			purge_sessions_version="$purge_sessions_current_version"
			sudo sed -i '\!^purge_sessions_version =!{h;s!=.*!= '"$purge_sessions_version"'!};${x;\!^$!{s!!purge_sessions_version = '"$purge_sessions_version"'!;H};x}' $drawpile_configuration_values_file
		elif [[ "$purge_sessions_version" = "$purge_sessions_current_version" ]]; then
			echo "The ./purge-sessions script is up to date."
		else
			echo "This message for ./purge-sessions script should not be visible - 1."
		fi
	else
		echo "This message for ./purge-sessions script should not be visible - 2."
	fi
fi
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------

echo
echo '--------------------------------------------------------------------------------'
echo '--------------------------------------------------------------------------------'
echo
# Session files are either .session or .sesssion.archived.
# The actual recordings are .dprec or .dprec.archived.
SessionTextFiles=$(sudo find "$dp_install_loc_sessions" -name "*.sessio*")
SessionTextFiles_active=$(sudo find "$dp_install_loc_sessions" -name "*.session")
SessionTextFiles_archived=$(sudo find "$dp_install_loc_sessions" -name "*.session.archived")

session_recordings_archived=$(sudo find "$dp_install_loc_sessions" -name "*.dprec.archived")
session_recordings=$(sudo find "$dp_install_loc_sessions" -name "*.dpre*")

# Uses stored info from variable and prints in nicer looking manner
NumberOfSessionTextFiles=$(printf '%s\n' "$SessionTextFiles" | wc -l)
NumberOfSessionTextFiles_active=$(printf '%s\n' "$SessionTextFiles_active" | wc -l)
NumberOfSessionTextFiles_archived=$(printf '%s\n' "$SessionTextFiles_archived" | wc -l)

number_of_session_recordings_archived=$(printf '%s\n' "$session_recordings_archived" | wc -l)
number_of_session_recordings=$(printf '%s\n' "$session_recordings" | wc -l)

disk_sessions_size=$( du -hs "$dp_install_loc_sessions" | awk '{ print $1 }'| sed 's/ //g' )

# Requires another search and slows down script
# sudo find "$dp_install_loc_sessions" -name "*.sessio*" | wc -l
# --------------------------------------------------------------------------------
echo "${bold}${cyan}Current Size of file-backed sessions folder:${normal}"
echo "                $disk_sessions_size"
echo
echo "Total Archived DPREC Recordings    : $number_of_session_recordings_archived"
echo "Total DPREC Recordings             : $number_of_session_recordings"
echo
echo "Total Active Session & DPREC Files : $NumberOfSessionTextFiles_active"
echo "Total Archived Session Files       : $NumberOfSessionTextFiles_archived"
echo "Total Session Text Files to search : $NumberOfSessionTextFiles" 
echo "     Displaying 10 at max . . ."
echo
# Uses stored info from variable and prints in nicer looking manner
printf "$SessionTextFiles" | awk 'NR<=10'
echo
# Requires another search and slows down script
# sudo find "$dp_install_loc_sessions" -name "*.sessio*" | awk 'NR<=10'
# --------------------------------------------------------------------------------
cd "$dp_install_loc_sessions"
echo '--------------------------------------------------------------------------------'
echo '--------------------------------------------------------------------------------'
echo
echo 'What operation would you like to perform?'
echo
echo " 1 - Search and copy data to folder."
echo "       Fastest but no preview."
echo " 2 - Search, copy to new folder, and generate JPGs."
echo "       Slowest option with images."
echo " 3 - Search, copy to new folder, and generate JPG for last in series."
echo "       Fastest option with one image."
echo
echo " 8 - Delete old session archives."
echo "       If server storage disk fills up, Drawpile-srv stops working."
echo "       Use this option to set up an automated cleanup task."
echo
echo " 9 - Exit script."
echo
while :; do
	read -r -p "${bold}${cyan}Please select one of the above options:${normal} " search_query_type
	echo
	if (( "$search_query_type" >= "1" && "$search_query_type" <= "3" || "$search_query_type" == "8" || "$search_query_type" == "9" )); then
		break
	else
		echo
		echo "${bold}${red}Invalid input selection, try again.${normal}"
		echo
		echo ----------------------------------------------------------------------------------
		echo
	fi
done
echo
echo '--------------------------------------------------------------------------------'
echo '--------------------------------------------------------------------------------'
echo
if (( "$search_query_type" >= "1" && "$search_query_type" <= "3" )); then
	function SearchQueryPrompt {
		echo 'Example information that may be found in the files that can be searched...'
		echo
		echo 'FILE 01gwwgv9kgbpew4wnghftjjxdg.dprec'
		echo 'FOUNDER UsernameHere'
		echo 'FLAGS persistent preserveChat nsfm authonly idleoverride allowweb'
		echo 'AUTORESET 15728640'
		echo 'USER 1 UsernameHere'
		echo 'TITLE This is an example session title'
		echo
		echo "${bold}${cyan}Good search example:${normal} TITLE This is an example session title"
		echo "${bold}${cyan}Bad search example:${normal}  example title"
		echo
		while :; do
			read -p "${bold}${cyan}What would you like to attempt searching for:${normal} " SearchQuery
			echo
			if [ -z "$SearchQuery" ] ; then
				echo
				echo "${bold}${red}Invalid input selection, try again.${normal}"
				echo
				echo ----------------------------------------------------------------------------------
				echo
			else
				break
			fi
		done
	}

	SearchQueryPrompt

	while :; do
		if test -n "$(sudo find "$dp_install_loc_sessions" -name "*.sessio*" | grep -li "$SearchQuery" *.sessio*)"; then
		   echo "${bold}${green}Results located!${normal}";
		   echo
		   break
		else
		   echo "${bold}${red}No results found, please try again.${normal}";
		   echo
		   echo '--------------------------------------------------------------------------------'
		   echo
		   SearchQueryPrompt
		fi
	done
	echo
	echo '--------------------------------------------------------------------------------'
	echo '--------------------------------------------------------------------------------'
	echo
	SearchResults=$(sudo find "$dp_install_loc_sessions" -name "*.sessio*" | grep -li "$SearchQuery" *.sessio*)
	NumberOfSearchResults=$(printf '%s\n' "$SearchResults" | wc -l)

	echo Session Search results: $NumberOfSearchResults
	echo
	# echo "    Note: May count incorrect number of found files, as it counts by new"
	# echo "          lines in search results. The actual files should be listed below."
	# echo "          No results found is typically the cause of this error."

	printf "$SearchResults"
	echo
	echo
	echo '--------------------------------------------------------------------------------'
	echo '--------------------------------------------------------------------------------'
	echo
	echo "Please specify the max number of files you wish to retrieve from each"
	echo "session. This will start with the most recent file and go to the oldest."
	echo
	echo "If a session went through a reset 30 times, there are 30 recording files"
	echo "     you could retrieve. You might only want to grab the files since the"
	echo "     last 3 resets. If your search result finds another session that only"
	echo "     had 2 resets, the script will grab all files."
	echo
	read -p "${bold}${cyan}Please enter a number:${normal} " SearchQueryNumber

	if [ -z "$SearchQueryNumber" ] ; then
		echo
		echo No value selected. Picking 3 sessions.
		sleep 5
		SearchQueryNumber=3
	fi

	if (( "$SearchQueryNumber" >= "1" )) ; then
		# Do nothing as no error was detected.
		# Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
		:
	else
		while :; do
			echo
			echo An invalid value was entered. Please try again.
			echo
			echo '--------------------------------------------------------------------------------'
			echo
			read -r -p "${bold}Please enter a number:${normal} " SearchQueryNumber
				if [ -z "$SearchQueryNumber" ] ; then
					echo
					echo No value selected. Picking 3 sessions.
					sleep 5
					SearchQueryNumber=3
					break
				fi
				if (( "$SearchQueryNumber" >= "1" )) ; then
					break
				else
					# Do nothing as no error was detected.
					# Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
					:
					continue
				fi
		done
	fi

	echo
	echo '--------------------------------------------------------------------------------'
	echo '--------------------------------------------------------------------------------'
	echo
	SaveSearchResults=$script_directory/$SearchQuery

	echo "The session file, and $SearchQueryNumber DPREC files will be copied to "
	echo "     $SaveSearchResults"
	echo
	echo Sessions will be placed into folders by date, time, and session title.
	echo Special characters will be removed to avoid problems with the file system.
	echo
	echo "${bold}${red}If not correct, press Ctrl + C to exit the script. ${normal}"
	echo "${bold}${green}Otherwise, press any key to continue.${normal}"
	echo
	pause
	echo
	sudo mkdir -p -v "$SaveSearchResults"
	sudo chown $current_username "$SaveSearchResults" -R
	sudo chmod 777 "$SaveSearchResults" -R
	echo
	if [[ -e  "/usr/local/bin/drawpile-cmd" ]]; then
		LocationCreatedExecutable=/usr/local/bin
	elif [[ -e  "/usr/bin/drawpile-cmd" ]]; then
		LocationCreatedExecutable=/usr/bin
	else
			echo "Was unable to determine location of created executable."
			echo "This will cause issues with the script."
			echo
			sleep 30s
			exit
	fi
	echo
	echo "$SearchResults" | while IFS= read -r line ; 
	do
		echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
		echo
		cd "$dp_install_loc_sessions"
		Filename1=$( echo $line | sudo sed 's/.archived//g' | sudo sed 's/.session//g' ) ;
		echo $Filename1 is the session name... 
		echo
		# JPEGname=$( echo $line | sudo sed 's/.dprec.archived/-1.jpeg/g' ) ;
		# echo $JPEGname JPEGname
		# SessionArchiveFile=$( echo "$line" | cut -c 1-36 ) ; 
		# echo $SessionArchiveFile SessionArchiveFile
		FileModDate=$(date -r "$Filename1"*sessio* "+%Y-%m-%d %H.%M.%S") ; 
		echo FileModDate __ - $FileModDate
		FileTitle=$(sudo find "$dp_install_loc_sessions/$line" -name "*.sessio*" | grep -m 1 "TITLE " "$dp_install_loc_sessions/$Filename1".sessio* | cut -c 7-100) ; 
		echo FileTitle ____ - $FileTitle
		clean_name6=$(echo "$FileTitle" | sed 's/+//g')
		clean_name5=$(echo "$clean_name6" | sed 's/|/-/g')
		clean_name4=$(echo "$clean_name5" | sed 's/&/and/g')
		clean_name3=$(echo "$clean_name4" | sed 's/;/ -/g')
		clean_name2="$(echo "$clean_name3" | perl -pe 's/[^a-zA-Z0-9_.-]/ /g')"
		NewName=$(echo $FileModDate - $clean_name2)
		echo NewName ______ - $NewName
		echo
		# sudo find "$dp_install_loc_sessions" -name "$Filename1.*" -exec cp {} "$SaveSearchResults" \;
		cd "$SaveSearchResults"
		sudo mkdir -p -v "$SaveSearchResults/$NewName"
		cd "$SaveSearchResults/$NewName"
		# --------------------------------------------------------------------------------
		if [[ -f "$dp_install_loc_sessions/$Filename1.session" ]]; then
			sudo cp -p "$dp_install_loc_sessions/$Filename1.session" "$SaveSearchResults/$NewName"
		elif [[ -f "$dp_install_loc_sessions/$Filename1.session.archived" ]]; then
			sudo cp -p "$dp_install_loc_sessions/$Filename1.session.archived" "$SaveSearchResults/$NewName"
		else
			echo This message regarding session file copying should not be visible.
		fi
		
		CopyMaxNumberDprecFiles=$(sudo find "$dp_install_loc_sessions/" -name "$line" | grep -i "File $Filename1*" "$dp_install_loc_sessions/$line" | tail -$SearchQueryNumber) ; 
		echo "$CopyMaxNumberDprecFiles"
		echo
		echo "$CopyMaxNumberDprecFiles" | while IFS="," read -r line3 ; 
		do
			Filename2=$( echo $line3 | sudo sed 's/FILE //g' ) ;
			if [[ -f "$dp_install_loc_sessions/$Filename2" ]]; then
				sudo cp -p "$dp_install_loc_sessions/$Filename2" "$SaveSearchResults/$NewName"
			elif [[ -f "$dp_install_loc_sessions/$Filename2.archived" ]]; then
				sudo cp -p "$dp_install_loc_sessions/$Filename2.archived" "$SaveSearchResults/$NewName"
			else
				echo This message regarding session dprec copying should not be visible.
			fi
		done
		# --------------------------------------------------------------------------------
		sudo chown $current_username "$SaveSearchResults/$NewName" -R
		sudo chmod 777 "$SaveSearchResults/$NewName" -R
		echo
		if test -n "$(find . -name '*.session.archived' | sed 'p;s/session.archived/session/')"; then
			echo "Session files with archive extension, renaming...";
			find . -name '*.session.archived' | sed 'p;s/session.archived/session/' | xargs -d '\n' -n 2 mv
		else
			echo "No session files with archive extension, skipping step.";
		fi
		
		if test -n "$(find . -name '*.dprec.archived' | sed 'p;s/dprec.archived/dprec/')"; then
			echo "Dprec files with archive extension, renaming...";
			find . -name '*.dprec.archived' | sed 'p;s/dprec.archived/dprec/' | xargs -d '\n' -n 2 mv
		else
			echo "No dprec files with archive extension, skipping step.";
		fi
		echo
		pwd
		echo

		if [ "$search_query_type" == "1" ]; then
			# echo " 1 - Search and copy data to folder."
			# echo "       Fastest but no preview."
			:
			# Do nothing as no error was detected.
			# Symbol --> : (a colon) --> Do nothing beyond expanding arguments and performing redirections. The return status is zero.
		elif [ "$search_query_type" == "2" ]; then
			# echo " 2 - Search, copy to new folder, and generate JPGs."
			# echo "       May take a long time to generate all images."
			echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
			echo ${bold}${underline}Beginning Search through DPREC Recordings for Corresponding JPEG Files.${normal}
			echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
			echo
			DprecFiles=$(find . -type f -name "*.dprec" | sed 's/.\///g')
			echo "$DprecFiles"
			echo

			echo "$DprecFiles" | while IFS="," read -r line2 ; 
			do
				echo 
				echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
				echo
				pwd
				JPEGname=$( echo $line2 | sudo sed 's/.dprec/-1.jpeg/g' ) ;
				# echo J $JPEGname
				SessionArchiveFile=$(find . -type f -name "*.session" | sed 's/.\///g')
				# echo SessionArchive $SessionArchiveFile
				LastFileOfSession=$( egrep "^FILE" "$SessionArchiveFile" | tail -n 1 | cut -d ' ' -f 2-3 )
				# echo L $LastFileOfSession
				FileModDate2=$(date -r "$line2" "+%Y-%m-%d %H.%M.%S") ; 
				# echo FDate $FileModDate2
				FileTitle2=$(grep -m 1 "TITLE " "$SessionArchiveFile" | cut -c 7-100) ; 
				# echo FTitle $FileTitle2
				clean_name6=$(echo "$FileTitle2" | sed 's/+//g')
				clean_name5=$(echo "$clean_name6" | sed 's/|/-/g')
				clean_name4=$(echo "$clean_name5" | sed 's/&/and/g')
				clean_name3=$(echo "$clean_name4" | sed 's/;/ -/g')
				clean_name2="$(echo "$clean_name3" | perl -pe 's/[^a-zA-Z0-9_.-]/ /g')"
				# echo clean name $clean_name2
				NewName2=$( echo $FileModDate2 - $clean_name2.jpg )
				# echo N $NewName2
				echo
				if [[ -e "$SaveSearchResults/$NewName/$NewName2" ]]; then
					echo "${green}JPEG Located${normal}: $NewName2".jpeg
					echo "This file corresponds to DPREC Recording found, skipping file: $line2"
				else
					echo "${red}No JPEG found, creating file:${normal} $NewName2"
					echo "File above being created from: $line2"
					echo
					drawpile-cmd -a -A "$line2"
					echo
					echo
					if [[ -f "$JPEGname" ]]; then
							echo "${red}Renaming file to user friendly readable format.${normal}"
							echo
							mv -T "$JPEGname" "$NewName2" && echo ${green}"Renamed successfully." ${normal}
					fi
				fi
			done
			echo
			echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
			echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
		elif [ "$search_query_type" == "3" ]; then	
			# echo " 3 - Search, copy to new folder, and generate last few JPGs."
			# echo "       Can select number at max to create images of DPRECs."
			echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
			echo ${bold}${underline}Beginning Search through DPREC Recordings for Corresponding JPEG Files.${normal}
			echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
			echo
			DprecFiles=$(find . -type f -name "*.dprec" | sed 's/.\///g')
			echo "$DprecFiles"
			echo

			echo "$DprecFiles" | while IFS="," read -r line2 ; 
			do
				echo 
				echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
				echo
				pwd
				JPEGname=$( echo $line2 | sudo sed 's/.dprec/-1.jpeg/g' ) ;
				# echo J $JPEGname
				SessionArchiveFile=$(find . -type f -name "*.session" | sed 's/.\///g')
				# echo SessionArchive $SessionArchiveFile
				LastFileOfSession=$( egrep "^FILE" "$SessionArchiveFile" | tail -n 1 | cut -d ' ' -f 2-3 )
				# echo L $LastFileOfSession
				FileModDate2=$(date -r "$line2" "+%Y-%m-%d %H.%M.%S") ; 
				# echo FDate $FileModDate2
				FileTitle2=$(grep -m 1 "TITLE " "$SessionArchiveFile" | cut -c 7-100) ; 
				# echo FTitle $FileTitle2
				clean_name6=$(echo "$FileTitle2" | sed 's/+//g')
				clean_name5=$(echo "$clean_name6" | sed 's/|/-/g')
				clean_name4=$(echo "$clean_name5" | sed 's/&/and/g')
				clean_name3=$(echo "$clean_name4" | sed 's/;/ -/g')
				clean_name2="$(echo "$clean_name3" | perl -pe 's/[^a-zA-Z0-9_.-]/ /g')"
				# echo clean name $clean_name2
				NewName2=$( echo $FileModDate2 - $clean_name2.jpg )
				# echo N $NewName2
				echo
				if [[ "$LastFileOfSession" == "$line2" ]]; then
					echo "Found last file in session series. Analyzing if JPG exists."
					echo
					if [[ -e "$SaveSearchResults/$NewName/$NewName2" ]]; then
						echo "${green}JPEG Located${normal}: $NewName2".jpeg
						echo "This file corresponds to DPREC Recording found, skipping file: $line2"
					else
						echo "${red}No JPEG found, creating file:${normal} $NewName2"
						echo "File above being created from: $line2"
						echo
						drawpile-cmd -a -A "$line2"
						echo
						echo
						if [[ -f "$JPEGname" ]]; then
							echo "${red}Renaming file to user friendly readable format.${normal}"
							echo
							mv -T "$JPEGname" "$NewName2" && echo ${green}"Renamed successfully." ${normal}
						fi
					fi
				else
					echo "Not the last file in the session series. Moving on."
					echo
				fi
			done
			echo
			echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
			echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
		else
			echo "This message should not be visible."
		fi
	done
	echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
		echo
		echo "${bold}${cyan}Final step ... changing permissions to allow all${normal}"
		echo "${bold}${cyan}     to modify and access...${normal}"
		echo
		sudo chown $current_username "$SaveSearchResults"
		sudo chmod 777 "$SaveSearchResults"
		# sleep 5
		cd "$SaveSearchResults"
	echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
	echo
	echo
	echo "Windows users can use WinSCP to retrieve these files."
	echo "The files are located in this directory below: "
	echo "     $SaveSearchResults"
	echo
	echo "${bold}${cyan}Operations completed.${normal}"
	echo
elif [ "$search_query_type" == "8" ]; then
	path_to_delete_parameter="$dp_install_loc/$script_created_location_sessions"
	# Comment out the above line and use line below for custom location if testing.
	# path_to_delete_parameter=/home/$USER/Public/sessions-2024-05-test
	disk_blocks=$( df -H --output=size / | awk ' NR==2 ' | sed 's/ //g' )
	disk_in_use=$( df -H --output=used / | awk ' NR==2 ' | sed 's/ //g' )
	disk_available=$( df -H --output=avail / | awk ' NR==2 ' | sed 's/ //g' )
	disk_pcent=$( df -H --output=pcent / | awk ' NR==2 '| sed 's/ //g' )

	echo
	echo "${bold}${cyan}Current Disk Info: df -H${normal}"
	df -H
	echo
	echo "${bold}${cyan}Current Disk Values:${normal}"
	echo "${bold}Blocks        :${normal} $disk_blocks"
	echo "${bold}Used          :${normal} $disk_in_use"
	echo "${bold}Available     :${normal} $disk_available"
	echo "${bold}Percent Used  :${normal} $disk_pcent"
	echo
	echo "${bold}${cyan}Size of file-backed sessions folder:${normal}"
	echo "                $disk_sessions_size"
	echo

	echo ${bold}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~${normal}
	
	variable_to_read_1="age_to_delete_parameter"
	variable_to_read_2="size_to_delete_parameter"
	variable_to_read_3=""	
	
	value_description_1="Value above is the length of time to retain archives. Older files are deleted."
	value_description_2=" "
	value_description_3="The newest file in the set of session files determines the age of a session,"
	value_description_4="so if it has a recording from last year and one from 2 seconds ago, the "
	value_description_5="session is considered to be 2 seconds old overall. Sessions that are still"
	value_description_6="running are not touched, even if they have individual recording files that"
	value_description_7="are older than set time frame. However, old files will be deleted if the total"
	value_description_8="total size of backups exceeds the limit we will set later. This ensures "
	value_description_9="backups are made available for retrievability."
	value_description_10=" "
	value_description_11="If the total size of session files exceeds a set size, the oldest, fully"
	value_description_12="archived sessions will be deleted until enough space is freed. The newest"
	value_description_13="file in a set of session files determines the age of that session, so if"
	value_description_14="a session has one recording from last year and one from 2 seconds ago, it"
	value_description_15="will be considered 2 seconds old overall."
	value_description_16=" "
	value_description_17="If that doesn't free enough space, archived recordings of still-running"
	value_description_18="sessions are deleted as well, oldest first. Active files of running "
	value_description_19="sessions are never touched though, so if deleting all archived files "
	value_description_20="still doesn't make enough room, the script just exits with an error."
	value_description_21=" "
	value_description_22="If you need to change the auto clean scheduled task or run a manual"
	value_description_23="cleanup, answer no. Otherwise, answer yes."
	value_description_24=" "
	value_description_25="Value below represents the max size of the backups."

	if ! sudo crontab -u root -l | grep '#Drawpile Archive File Cleanup' > /dev/null 2>&1; then
		echo
		echo "A scheduled cleanup task was not found (or not yet set up)."
		echo "Running set up to configure the task."
		echo
		echo
		maybe_use_config_value=n
	else
		echo
		read_stored_config_value_query_function
	fi
	
	if [ "$maybe_use_config_value" == "y" ] || [ "$maybe_use_config_value" == "Y" ] || [ "$maybe_use_config_value" == "yes" ] || [ "$maybe_use_config_value" == "YES" ] || [ "$maybe_use_config_value" == "Yes" ]; then
		echo "Storing value and moving on."
		age_to_delete_parameter=$read_stored_config_value_query_1
		size_to_delete_parameter=$read_stored_config_value_query_2
	elif [ "$maybe_use_config_value" == "n" ] || [ "$maybe_use_config_value" == "N" ] || [ "$maybe_use_config_value" == "no" ] || [ "$maybe_use_config_value" == "NO" ] || [ "$maybe_use_config_value" == "No" ]; then
		while :; do
			echo "We need to set both a timeframe at which older files will be deleted and"
			echo "a size limit to prevent the file backed sessions from growing too large."
			echo "Failure to do so will prevent Drawpile-srv from working at all."
			echo
			echo
			echo "${bold}${cyan}Delete archived session files where the session is older than a set limit.${normal}"
			echo
			echo "The newest file in the set of session files determines the age of a session,"
			echo "so if it has a recording from last year and one from 2 seconds ago, the "
			echo "session is considered to be 2 seconds old overall. Sessions that are still"
			echo "running are not touched, even if they have individual recording files that"
			echo "are older than set time frame. However, old files will be deleted if the total"
			echo "total size of backups exceeds the limit we will set later. This ensures "
			echo "backups are made available for retrievability."
			echo
			echo "Age can be configured in terms a number and a unit, such as days, hours,"
			echo "minutes, or seconds. Only the first letter of the unit matters, so "
			echo "the value values '10 days', '10DAY' or '10d' all mean the same thing."
			echo
			read -r -p "${bold}${cyan}Please set a valid timeframe unit:${normal} " age_to_delete_parameter
			echo
			echo '--------------------------------------------------------------------------------'
			echo
			echo "${bold}${cyan}Delete archived session files until the maximum given size is reached.${normal}"
			echo
			echo "If the total size of session files exceeds a set size, the oldest, fully"
			echo "archived sessions will be deleted until enough space is freed. The newest"
			echo "file in a set of session files determines the age of that session, so if"
			echo "a session has one recording from last year and one from 2 seconds ago, it"
			echo "will be considered 2 seconds old overall."
			echo
			echo "If that doesn't free enough space, archived recordings of still-running"
			echo "sessions are deleted as well, oldest first. Active files of running "
			echo "sessions are never touched though, so if deleting all archived files "
			echo "still doesn't make enough room, the script just exits with an error."
			echo
			echo "${bold}${cyan}For reference:${normal}"
			echo "1 TiB (Terabyte) = 1,024 GiB (Gigabytes) = 1,048,576 MiB (Megabytes) = "
			echo "1,073,741,824 KiB (Kilobytes) = 1,099,511,627,776 Bytes = 1 TiB (Terabyte)"
			echo
			echo "${bold}${cyan}Recommended Size Guidelines:${normal}"
			echo "     Should never be larger than the total disk size ( $disk_blocks )."
			echo "     The value you should use depends on the situation."
			echo "       - If the disk is completely full ( $disk_pcent used, consider"
			echo "           anything between 90 to 100% for this situation ), then you"
			echo "           should use something smaller than the size of the sessions"
			echo "           folder ( $disk_sessions_size )."
			echo "           Hopefully you are not experiencing this problem, space is "
			echo "           required to do updates."
			echo "       - If the disk is not highly used ( $disk_pcent used, consider "
			echo "           anything under 40% for this situation ), then a value that"
			echo "           is half the size of the available space ( $disk_available ) would be"
			echo "           appropriate to maximize the number of backups available"
			echo "           in the event of an art-emergency."
			echo "       - If neither is true, then probably something similar to the current "
			echo "           size of the sessions folder ( $disk_sessions_size ) is acceptable assuming"
			echo "           the size is being reported in GB ( Gigabytes )."
			echo
			echo "Some personal judgement is required here, but hopefully the above helps."
			echo
			echo "Size is a number and a unit, which can be one of TiB, GiB, MiB, KiB or B."
			echo "Only the first letter of the unit matters, so '10GiB', '10G' or "
			echo "'10 gigabytes' all mean the same thing."
			echo
			read -r -p "${bold}${cyan}Please set a valid size unit:${normal} " size_to_delete_parameter
			echo
			echo '--------------------------------------------------------------------------------'
			echo	
			echo "${bold}${cyan}Testing inputs to ensure they are valid.${normal}"
			echo		
			if ! $dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-age="$age_to_delete_parameter" "$path_to_delete_parameter" --dry-run &>/dev/null; then
				echo "${bold}${red}Failure: time input is invalid.${normal}"
				age_to_delete_parameter_test=fail
				$dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-age="$age_to_delete_parameter" "$path_to_delete_parameter" --dry-run
			else
				echo "${bold}${green}Success: time input is valid.${normal}"
				age_to_delete_parameter_test=pass
			fi
			echo
			if ! $dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-size="$size_to_delete_parameter" "$path_to_delete_parameter" --dry-run &>/dev/null; then
				echo "${bold}${red}Failure: size input is invalid.${normal}"
				size_to_delete_parameter_test=fail
			else
				echo "${bold}${green}Success: size input is valid.${normal}"
				size_to_delete_parameter_test=pass
				$dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-size="$size_to_delete_parameter" "$path_to_delete_parameter" --dry-run
			fi

			if [[ "$age_to_delete_parameter_test" == "pass" && "$size_to_delete_parameter_test" == "pass" ]]; then
				echo
				echo '--------------------------------------------------------------------------------'
				echo
				if sudo crontab -u root -l | grep '#Drawpile Archive File Cleanup' > /dev/null 2>&1; then
					echo
					echo "${bold}${yellow}Crontab set up for Archive File Cleanup.${normal}"
					echo "${bold}${yellow}Removing old info before adding new content.${normal}"
					sudo crontab -u root -l | grep -v '#Drawpile Archive File Cleanup' | sudo crontab -u root -
					echo
				else
					:
					# echo No crontab, sadge. Adding in crontab jerb.
				fi
				echo "${bold}${cyan}Would you like to create a timed job that runs once per day?${normal}"
				echo "${bold}${cyan}The job runs 12:00 AM, age check followed by size check.${normal}"
				# echo "${bold}${cyan}Age check occurs at 12:00 AM, size check cleanup at 1:00 AM.${normal}"
				echo
				echo "1 - Yes"
				echo "2 - No"
				echo
				while :; do
					read -r -p "${bold}${cyan}Please select one of the above options, 1 or 2:${normal} " drawpile_archive_file_cleanup_crontab
					echo
					if (( "$drawpile_archive_file_cleanup_crontab" >= "1" && "$drawpile_archive_file_cleanup_crontab" <= "2" )); then
						break
					else
						echo
						echo "${bold}${red}Invalid input selection, try again.${normal}"
						echo
						echo ----------------------------------------------------------------------------------
						echo
					fi
				done
				
				if [ "$drawpile_archive_file_cleanup_crontab" == "1" ]; then
					echo "Adding crontab job to auto clean files."
					(sudo crontab -l -u root 2>>/dev/null; echo "0 0 * * * $dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-age=\"$age_to_delete_parameter\" \"$path_to_delete_parameter\" && $dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-size=\"$size_to_delete_parameter\" \"$path_to_delete_parameter\" #Drawpile Archive File Cleanup") | sudo crontab -u root -
					# (sudo crontab -l -u root 2>>/dev/null; echo "0 1 * * * $dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-size=\"$size_to_delete_parameter\" \"$path_to_delete_parameter\" #Drawpile Archive File Cleanup") | sudo crontab -u root -
				elif [ "$drawpile_archive_file_cleanup_crontab" == "2" ]; then
					echo "Skipping crontab job to be added."
				else
					echo "This message should not be visible for Drawpile Archive File Cleanup via Crontab."
				fi
				
				break
			else
				echo
				echo "${bold}${red}Errors detected. Please try again.${normal}"
				echo
				echo '--------------------------------------------------------------------------------'
				echo
				continue
			fi
		done
		sudo sed -i '\!^age_to_delete_parameter =!{h;s!=.*!= '"$age_to_delete_parameter"'!};${x;\!^$!{s!!age_to_delete_parameter = '"$age_to_delete_parameter"'!;H};x}' $drawpile_configuration_values_file
		sudo sed -i '\!^size_to_delete_parameter =!{h;s!=.*!= '"$size_to_delete_parameter"'!};${x;\!^$!{s!!size_to_delete_parameter = '"$size_to_delete_parameter"'!;H};x}' $drawpile_configuration_values_file
	else
		echo "This message should not be visible."
	fi
	echo
	echo '--------------------------------------------------------------------------------'
	echo
	while :; do
		echo "${bold}${cyan}Current Disk Values:${normal}"
		echo "${bold}Blocks        :${normal} $disk_blocks"
		echo "${bold}Used          :${normal} $disk_in_use"
		echo "${bold}Available     :${normal} $disk_available"
		echo "${bold}Percent Used  :${normal} $disk_pcent"
		echo
		echo "${bold}${cyan}Size of file-backed sessions folder:${normal}"
		echo "                $disk_sessions_size"
		echo	
		echo "${bold}${cyan}Cleanup time!${normal}"
		echo
		echo "1 - Dry run - test files to be deleted."
		echo "6 - Clean up old files."
		echo
		echo "9 - Exit cleanup script."
		echo
		read -r -p "${bold}${cyan}Please select one of the above options:${normal} " drawpile_archive_file_cleanup_run
		
		# if (( "$drawpile_archive_file_cleanup_run" == "1" || "$drawpile_archive_file_cleanup_run" == "6" || "$drawpile_archive_file_cleanup_run" == "9" )); then
		if (( "$drawpile_archive_file_cleanup_run" == "1" )); then
			echo
			echo ----------------------------------------------------------------------------------
			echo ----------------------------------------------------------------------------------
			echo
			echo "${bold}${yellow}Dry Run - Archive File Cleanup in Age Mode.${normal}"
			$dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-age="$age_to_delete_parameter" "$path_to_delete_parameter" --dry-run
			echo
			echo ----------------------------------------------------------------------------------
			echo
			echo "${bold}${yellow}Dry Run - Archive File Cleanup in Size Mode.${normal}"
			$dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-size="$size_to_delete_parameter" "$path_to_delete_parameter" --dry-run
			echo
			echo ----------------------------------------------------------------------------------
			echo ----------------------------------------------------------------------------------
			echo
			echo "${bold}${yellow}Returning to prior menu.${normal}"
			echo
		elif (( "$drawpile_archive_file_cleanup_run" == "6" )); then
			echo
			echo ----------------------------------------------------------------------------------
			echo ----------------------------------------------------------------------------------
			echo
			echo "${bold}${red}Running - Archive File Cleanup in Age Mode.${normal}"
			$dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-age="$age_to_delete_parameter" "$path_to_delete_parameter"
			echo
			echo ----------------------------------------------------------------------------------
			echo
			echo "${bold}${red}Running - Archive File Cleanup in Size Mode.${normal}"
			$dp_install_loc/$script_created_location_server_scripts/./purge-sessions --maximum-size="$size_to_delete_parameter" "$path_to_delete_parameter"
			echo
			echo ----------------------------------------------------------------------------------
			echo ----------------------------------------------------------------------------------
			echo
			break
		elif (( "$drawpile_archive_file_cleanup_run" == "9" )); then
			break
		else
			echo
			echo "${bold}${red}Invalid input selection, try again.${normal}"
			echo
			echo ----------------------------------------------------------------------------------
			echo
		fi
	done
	echo "${bold}${cyan}Previous Disk Values:${normal}"
	echo "${bold}Blocks        :${normal} $disk_blocks"
	echo "${bold}Used          :${normal} $disk_in_use"
	echo "${bold}Available     :${normal} $disk_available"
	echo "${bold}Percent Used  :${normal} $disk_pcent"
	echo
	echo "${bold}${cyan}Previous Size of file-backed sessions folder:${normal}"
	echo "                $disk_sessions_size"
	
	disk_blocks=$( df -H --output=size / | awk ' NR==2 ' | sed 's/ //g' )
	disk_in_use=$( df -H --output=used / | awk ' NR==2 ' | sed 's/ //g' )
	disk_available=$( df -H --output=avail / | awk ' NR==2 ' | sed 's/ //g' )
	disk_pcent=$( df -H --output=pcent / | awk ' NR==2 '| sed 's/ //g' )
	disk_sessions_size=$( du -hs "$path_to_delete_parameter" | awk '{ print $1 }'| sed 's/ //g' )
	
	echo
	echo ----------------------------------------------------------------------------------
	echo
	echo "${bold}${cyan}Current Disk Info: df -H${normal}"
	df -H
	echo
	echo "${bold}${cyan}Current Disk Values:${normal}"
	echo "${bold}Blocks        :${normal} $disk_blocks"
	echo "${bold}Used          :${normal} $disk_in_use"
	echo "${bold}Available     :${normal} $disk_available"
	echo "${bold}Percent Used  :${normal} $disk_pcent"
	echo
	echo "${bold}${cyan}Current Size of file-backed sessions folder:${normal}"
	echo "                $disk_sessions_size"
	echo
	echo ----------------------------------------------------------------------------------
	echo
	echo "${bold}${green}Cleanup operations completed.${normal}"
	echo
elif [ "$search_query_type" == "9" ]; then
	echo "Exiting script."
else
	echo "This message should not be visible for selecting search method."
fi


sudo chmod 770 $app_installation_status_file
sudo chmod 770 $drawpile_configuration_values_file

} # this ensures the entire script is downloaded, the other part of this is located just after the script update and wget check. #
